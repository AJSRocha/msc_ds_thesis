---
title: "R Notebook"
output: html_notebook
---

https://rdrr.io/github/jabbamodel/JABBA/f/Tutorial%20Vignette.Rmd

https://github.com/jabbamodel/JABBA/blob/master/Tutorial_Vignette.md

https://www.iccat.int/Documents/CVSP/CV079_2022/n_1/CV079010675.pdf

https://www.sciencedirect.com/science/article/pii/S0165783618300845

```{r}
library(JABBA)
library(gplots)
library(coda)
library(rjags)
library(R2jags)
library("fitdistrplus")
library(reshape)

load('data/initial_data_occ_df_final.Rdata')
```

# Colour Schemes

```{r}
col_mis_w  = wes_palette('Zissou1',4)[1]
col_mis_s  = wes_palette('Zissou1',4)[3]                  
col_otb_w  = wes_palette('Zissou1',4)[2]
col_otb_s  = wes_palette('Zissou1',4)[4]
```

# Western Coast

```{r}
a = Sys.time()
input = df_effort_y %>% filter(fill == '1-Western Coast 2-Bottom Trawl')

jbinput_w = build_jabba(catch = data.frame('Year' = input$year_sale %>% as.numeric(),
                                         'otb' = input$catch),
                      cpue = data.frame('Year' = input$year_sale %>% as.numeric(),
                                        'otb' = input$lpue),
                      se = data.frame('Year' = input$year_sale %>% as.numeric(),
                                        'otb' = log(input$sd/input$lpue)),
                      scenario = 'TestRun',
                      model.type = 'Fox',
                      sigma.est = F,
                      fixed.obsE = 0.01)

b = Sys.time()
perf_jabba_preproc_otb_w = b-a


a = Sys.time()
bet_total_w = fit_jabba(jbinput_w,
                    ni = 30000, #number of iterations 
                    nt = 5, # thinning interval of saved iterations
                    nb = 5000, #burn-in
                    nc = 2, #number of mcmc chains initial values
                    init.values = FALSE, # 
                    init.K = NULL,
                    init.r = 0.81,
                    init.q = NULL,
                    peels = NULL, # NULL, # retro peel option
                    do.ppc = TRUE, # conducts and saves posterior predictive checks
                    save.trj = TRUE, # adds posteriors of stock, harvest and bk trajectories
                    save.all = FALSE, # add complete posteriors to fitted object
                    save.jabba = FALSE, # saves jabba fit as rdata object
                    save.csvs = FALSE, # option to write csv outputs
                    output.dir = 'scripts/jabba',
                    quickmcmc = TRUE,
                    seed = 123,
                    jagsdir = NULL,
                    verbose = TRUE)
b = Sys.time()
perf_jabba_fit_otb_w = b-a

a = Sys.time()
xtable(bet_total_w$estimates) %>% 
  print(.,
        type = "latex",
        file = "tables/otb/res_jabba_est_otb_w.tex", 
        include.rownames = T,
        only.contents = T)


jbplot_ppdist(bet_total_w, mfrow = c(2,3))

grid.echo()
fig = grid.grab()
ggsave(fig, dpi = 300, units = 'cm',
       height = 10, width = 10, filename = 'plots/otb/res_jabba_pardist_w.png')

# dev.new()
png('plots/otb/res_jabba_w.png', height = 10, width = 10, units = 'in', res = 300)
par(mfrow = c(2,2), mar = c(5, 5, 5, 5))
jbplot_trj(bet_total_w,type="BBmsy", add = T)
jbplot_trj(bet_total_w,type="FFmsy", add = T)
jbplot_kobe(bet_total_w, add = T)
jbplot_spphase(bet_total_w, add = T)
dev.off()

b = Sys.time()
perf_jabba_render_otb_w = b-a
```

# Southern Coast

```{r}
a = Sys.time()
input = df_effort_y %>% filter(fill == '2-Southern Coast 2-Bottom Trawl')

jbinput_s = build_jabba(catch = data.frame('Year' = input$year_sale %>% as.numeric(),
                                         'otb' = input$catch),
                      cpue = data.frame('Year' = input$year_sale %>% as.numeric(),
                                        'otb' = input$lpue),
                      se = data.frame('Year' = input$year_sale %>% as.numeric(),
                                        'otb' = log(input$sd/input$lpue)),
                      scenario = 'TestRun',
                      model.type = 'Fox',
                      sigma.est = F,
                      fixed.obsE = 0.01)

b = Sys.time()
perf_jabba_preproc_otb_s = b-a


a = Sys.time()
bet_total_s = fit_jabba(jbinput_s,
                    ni = 30000, #number of iterations 
                    nt = 5, # thinning interval of saved iterations
                    nb = 5000, #burn-in
                    nc = 2, #number of mcmc chains initial values
                    init.values = FALSE, # 
                    init.K = NULL,
                    init.r = 0.81,
                    init.q = NULL,
                    peels = NULL, # NULL, # retro peel option
                    do.ppc = TRUE, # conducts and saves posterior predictive checks
                    save.trj = TRUE, # adds posteriors of stock, harvest and bk trajectories
                    save.all = FALSE, # add complete posteriors to fitted object
                    save.jabba = FALSE, # saves jabba fit as rdata object
                    save.csvs = FALSE, # option to write csv outputs
                    output.dir = 'scripts/jabba',
                    quickmcmc = TRUE,
                    seed = 123,
                    jagsdir = NULL,
                    verbose = TRUE)
b = Sys.time()
perf_jabba_fit_otb_s = b-a

a = Sys.time()
xtable(bet_total_s$estimates) %>% 
  print(.,
        type = "latex",
        file = "tables/otb/res_jabba_est_otb_s.tex", 
        include.rownames = T,
        only.contents = T)


jbplot_ppdist(bet_total_s, mfrow = c(2,3))

grid.echo()
fig = grid.grab()
ggsave(fig, dpi = 300, units = 'cm',
       height = 10, width = 10, filename = 'plots/otb/res_jabba_pardist_s.png')

# dev.new()
png('plots/otb/res_jabba_s.png', height = 10, width = 10, units = 'in', res = 300)
par(mfrow = c(2,2), mar = c(5, 5, 5, 5))
jbplot_trj(bet_total_s,type="BBmsy", add = T)
jbplot_trj(bet_total_s,type="FFmsy", add = T)
jbplot_kobe(bet_total_s, add = T)
jbplot_spphase(bet_total_s, add = T)
dev.off()

b = Sys.time()
perf_jabba_render_otb_s = b-a
```

# Performance assessment

```{r}
perf_jabba = data.frame(
  'Framework' = c('JABBA - Bottom Trawl, Western Coast, Yearly data',
                  'JABBA - Bottom Trawl, Southern Coast'),
  'Pre-process' = c(perf_jabba_preproc_otb_w, perf_jabba_preproc_otb_s),
  'Model fit' = c(perf_jabba_fit_otb_w, perf_jabba_fit_otb_s),
  'Output Render' = c(perf_jabba_render_otb_w, perf_jabba_render_otb_s))

save(perf_jabba, file = 'benchmarks/jabba_otb.Rdata')
save(bet_total_s, bet_total_w, file = 'tables/otb/jabba_tables_otb.Rdata')

```




# Junk
















```{r, fig.width=20, fig.height=10}
# par(mfrow=c(3,2),mar = c(3.5, 3.5, 0.5, 0.1))
# jbplot_trj(bet_total,type="B",add=T)
# jbplot_trj(bet_total,type="F",add=T)
# jbplot_trj(bet_total,type="BBmsy",add=T)
# jbplot_trj(bet_total,type="FFmsy",add=T)
# jbplot_spphase(bet_total,add=T)
# jbplot_kobe(bet_total,add=T)
```

```{r}
# jbinput = build_jabba(catch = data.frame('Year' = df_y_MIS_W$year_sale %>% as.numeric(),
#                                          'otb' = df_y_OTB_W$QVENDA),
#                       cpue = data.frame('Year' = df_y_MIS_W$year_sale %>% as.numeric(),
#                                         'otb' = df_y_OTB_W$QVENDA/df_y_OTB_W$effort),
#                       scenario = 'TestRun',
#                       model.type = c('Schaefer'), #model.type = c("Schaefer", "Fox", "Pella", "Pella_m"),
#                       sigma.est = F,
#                       fixed.obsE = 0.01)
# 
# bet_otb = fit_jabba(jbinput,
#                     ni = 30000, #number of iterations 
#                     nt = 5, # thinning interval of saved iterations
#                     nb = 5000, #burn-in
#                     nc = 2, #number of mcmc chains initial values
#                     init.values = FALSE, # 
#                     init.K = NULL,
#                     init.r = NULL,
#                     init.q = NULL,
#                     peels = NULL, # NULL, # retro peel option
#                     do.ppc = TRUE, # conducts and saves posterior predictive checks
#                     save.trj = TRUE, # adds posteriors of stock, harvest and bk trajectories
#                     save.all = FALSE, # add complete posteriors to fitted object
#                     save.jabba = FALSE, # saves jabba fit as rdata object
#                     save.csvs = FALSE, # option to write csv outputs
#                     output.dir = 'scripts/jabba',
#                     quickmcmc = TRUE,
#                     seed = 123,
#                     jagsdir = NULL,
#                     verbose = TRUE)

```

```{r}
# jbinput = build_jabba(catch = data.frame('Year' = df_y_MIS_W$year_sale %>% as.numeric(),
#                                          'mis' = df_y_MIS_W$QVENDA),
#                       cpue = data.frame('Year' = df_y_MIS_W$year_sale %>% as.numeric(),
#                                         'mis' = df_y_MIS_W$QVENDA/df_y_MIS_W$effort),
#                       scenario = 'TestRun',
#                       model.type = 'Fox',
#                       sigma.est = F,
#                       fixed.obsE = 0.01)
# 
# bet_mis = fit_jabba(jbinput,quickmcmc=TRUE)
```



```{r}
# jbplot_catcherror(bet1)
# jbplot_ppdist(bet1)
# jbplot_cpuefits(bet1)
# jbplot_logfits(bet1)
```


JABBA requires a minimum of two input comma-separated value files (.csv) in the form of catch and abundance indices. The Catch input file contains the time series of year and catch by weight, aggregated across fleets for the entire fishery. Missing catch years or catch values are not allowed. JABBA is formulated to accommodate abundance indices from multiple sources (i.e., fleets) in a single cpue file, which contains all considered abundance indices. The first column of the cpue input is year, which must match the range of years provided in the Catch file. In contrast to the Catch input, missing abundance index values are allowed, such that different abundance indices may correspond to smaller portions of the catch time series. Optionally, an additional se input can be passed onto JABBA, containing standard error estimates associated with the abundance indices on a log scale. The se input is a third file, structurally identical to the cpue input. Alternatively, this feature can be used to apply different weighting to individual abundance indices by assigning varying coefficients of variation (CV) to each time series. If such weighting is implemented, it is advised that the CV chosen for each indexed year approximates the observed standard error on the log scale, such that the data weights are congruent with expectations as to how well the model should fit these data.






```{r, fig.width=20, fig.height=10}
# par(mfrow=c(3,2),mar = c(3.5, 3.5, 0.5, 0.1))
# jbplot_trj(bet_mis,type="B",add=T)
# jbplot_trj(bet_mis,type="F",add=T)
# jbplot_trj(bet_mis,type="BBmsy",add=T)
# jbplot_trj(bet_mis,type="FFmsy",add=T)
# jbplot_spphase(bet_mis,add=T)
# jbplot_kobe(bet_mis,add=T)
```

```{r, fig.width=20, fig.height=10}
# par(mfrow=c(2,2),mar = c(3.5, 3.5, 0.5, 0.1))
# jbplot_trj(bet_otb,type="B",add=T)
# jbplot_trj(bet_otb,type="F",add=T)
# # jbplot_trj(bet_otb,type="BBmsy",add=T)
# # jbplot_trj(bet_otb,type="FFmsy",add=T)
# jbplot_spphase(bet_otb,add=T)
# jbplot_kobe(bet_otb,add=T)
```


The R Prime file SWO_SA_prime_v1.1.R can be used to reproduce the analysis and figures from Winker et al. (2018), when used in conjuntion with JABBAv1.1.R and data from the South Atlantic Swordfish Fishery /SWO_SA. This tutorial explains the main segments of the Prime file setup.

Getting started
JABBA requires the installation of R and JAGS and the following R packages that can be directly installed within R

##><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><><><
## JABBA: Just Another Bayesian Biomass Assessment
## Input File for JABBA
## Developed by Henning Winker & Felipe Carvalho (Cape Town/Hawaii)  
##><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>


The three (or two) csv files are named so that the type classifier Catch, cpue and se is combined with the assessment name. In this example, we define assessment = SWO_SA, so that catchSWO_SA.csv, cpueSWO_SA.csv and seSWO_SA.csv.

All input files have to be saved in a folder that is named after the assessment, here /SWO_SA.

In the Prime file:
File = requires the path where the assessment folder is located
JABBA = requires the path where the JABBA model JABBAv1.1.R is located
version = determines the JABBA model version
assessment = assignes the assessment folder name





Basic settings
JABBA provides various Graphic, Output, Saving options that can be specified in the prime file. If not specified, JABBA will automatically use the default settings as specified on top of the JABBAv1.1.R code.



Looping through scenarios
JABBA makes it easy to run alternative scenarios in a loop. For this purpose, a unique name has to be assgined to each scenario. For example, a generic option to do this for 10 alternative scenarios is:

Scenarios = c(paste0("Scenario",1:10))

but individual names may be specified as well, e.g. Scenarios = c("Run_high_r","Run_medium_r","Run_low_r"). JABBA automatically creates a folder for each scenario, including the Input and output subfolders. Note that the type of model _Schaefer, _Fox and _Pella is automatically added to the name of scenario folder.



Input data manipulation
This section is optional. For the SWO_SA example, we use this section to manipulate the input cpue and se data for scenarios 1-3. For sceanarios 2-3, we remove the BRA_LL1 series. For the base-case scenario 3, we also use seperate time series (time-blocks) for Japan (JP_LL1 & JP_LL2) and Spain (SP_LL1 & SP_LL2), which we merge back into one index for JP_1 and on for SP_LL1 for scenarios 1-2. If the se input is provided, the same munipulations must be applied as for cpue.Again, always check if the manilupations were correctly applied.

JABBA provides provides the option to use a single averaged CPUE index instead of the individual abundance indices (see 2.5.1. State-Space model for averaging of abundance indices in Winker et al, 2018). This feature can be activated by setting meanCPUE = TRUE.


Prior and Process variance settings
Please see section 2.3.2. Prior specification in Winker et al. (2008) for details.

Most prior settings provide more than one option. For example, if the prior for K is meant to be specified as a lognormal prior set K.dist = c("lnorm","range")[1], whereas for a range set K.dist = c("lnorm","range")[2]. If the prior for K is specified as lognormal, e.g. K.prior = c(200000,1), it requires the untransformed mean K and the assumed CV. If the prior for K is specified as range, it requires the assumed minum and maximum values, e.g. K.prior = c(15000,1500000).

The r prior provides an additional option, in that it can be specified as a generic resiliance category Very low, Low, Medium or High, such as provided by FishBase. This requires specifying K.dist = c("lnorm","range")[2] (i.e. as a range) and then setting the K.prior equal to one of the above reliance categories, e.g. K.prior = "Low".


 
Both catchability q and the estimable observation variance $\sigma^2_{est,i}$ can be specified to be estimated: (1) for each CPUE index, (2) in groups or (3) as the same quantatity for all indices. For (1), simply provide a vector of unique integer in order for each index, e.g. sets.q = 1:(ncol(cpue)-1). For (2), set.q = can be specified by grouping similar indices, e.g. set.q = c(1,1,2,2,3). For (3), simply provide the indentifier 1 for all indices, e.g. sets.q = rep(1,ncol(cpue)-1). The exact same principles apply for assigning $\sigma^2_{est,i}$ to individual indices i, i.e. sets.var = 1:(ncol(cpue)-1) for case (1).

  
Projections under constant Total Allowable Catch (TAC)
JABBA enables projections under constant catch scenarios. JABBA automatically compares the difference between the last assessment year and the present year. The difference between these years is projected forward under the current catch, which could, for example, be determined based on updated catch inofrmation TACint = 10058 or by assuming an average catch based on the three most recent assessment years, such that TACint = mean(catch[nrow(catch)-3,2]:catch[nrow(catch),2]). All prjected posteriors can be saved a _projections.Rdata object, which can be easily passed on JABBAgoesFLR.R for further processing, including the production of Kobe projection matrices.

